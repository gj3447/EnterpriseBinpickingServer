# ApplicationStore 잠재적 문제점 및 개선 방향

현재 `ApplicationStore`는 매우 안정적으로 동작하지만, 향후 확장성 및 극단적인 동시성 환경을 고려했을 때 다음과 같은 잠재적 문제점들을 가지고 있습니다.

## 1. 너무 큰 범위의 단일 잠금 (Monolithic Lock)

### 문제점
- 모든 핸들러(`ImageHandler`, `ArucoHandler` 등)가 단 하나의 `threading.RLock` 인스턴스를 공유합니다.
- 이는 관련 없는 데이터에 대한 접근도 서로를 기다리게 만드는 **불필요한 대기(Contention)**를 유발할 수 있습니다.
- 향후 시스템이 복잡해질수록 이 단일 잠금이 **성능 병목(Bottleneck)** 지점이 될 가능성이 높습니다.

### 개선 방향
- 각 핸들러가 자신만의 독립적인 Lock을 소유하도록 변경합니다.
- 예: `self.images = ImageHandler(threading.RLock())`, `self.aruco = ArucoHandler(threading.RLock())`
- 이를 통해 핸들러 간의 독립성을 보장하고 동시 처리 성능을 극대화할 수 있습니다.

---

## 2. 데이터-메타데이터 분리 저장

### 문제점
- `ImageHandler`에서 이미지 데이터(`_latest_images`)와 해당 이미지의 타임스탬프(`_image_timestamps`)가 별개의 `TTLCache`에 저장됩니다.
- 이는 논리적으로 하나의 단위인 데이터를 물리적으로 분리하여 저장하는 방식으로, 코드 수정 시 **데이터 불일치(Inconsistency)**를 유발할 잠재적 위험을 내포합니다. (예: 데이터는 저장했으나 타임스탬프 저장을 누락하는 실수)
- 여러 캐시를 동시에 조회하여 상태를 조합하는 것은 **비원자적(Non-Atomic)**이며 구조를 복잡하게 만듭니다.

### 개선 방향
- 데이터와 메타데이터를 하나의 객체로 묶어 저장합니다.
- 예: `TTLCache`에 이미지 데이터(`np.ndarray`) 대신, `{"data": image, "timestamp": ts}`와 같은 딕셔너리나 전용 `dataclass`를 저장합니다.
- 이를 통해 데이터의 **무결성(Integrity)**을 보장하고 코드를 더 견고하게 만들 수 있습니다.

---

## 3. 타임스탬프 기반 조회 부재로 인한 경쟁 상태(Race Condition) 가능성

### 문제점
- 서비스 로직은 특정 `timestamp`를 가진 이벤트를 수신하지만, `Store`에서 이미지를 가져올 때는 `get_latest_image()`를 호출하여 단순히 **"가장 최신"**의 이미지를 가져옵니다.
- 이벤트 처리 지연이 발생하는 극단적인 경우, 이벤트의 타임스탬프와 실제로 처리하는 이미지의 타임스탬프가 일치하지 않는 **경쟁 상태(Race Condition)**가 발생할 수 있습니다.

### 개선 방향
- **(단기)** 현재 구조는 이벤트 처리 속도가 매우 빨라 문제가 발생할 확률이 극히 낮으므로, 구조의 단순함이 주는 이점이 더 큽니다. **현상 유지를 권장**합니다.
- **(장기/고도화)** `Store`에 `get_image_by_timestamp(ts)`와 같은 명시적인 조회 메서드를 추가하거나, `update_image`가 고유 ID를 반환하고 해당 ID로 조회하는 메커니즘을 도입하여 이 문제를 원천적으로 차단할 수 있습니다.

---

## 4. 확장성에 불리한 구조 (OCP 위반)

### 문제점
- `ImageHandler`는 `jpeg_images`, `transforms_images`처럼 새로운 종류의 처리된 이미지가 추가될 때마다, 새로운 `TTLCache` 속성과 `update_*`, `get_*` 메서드를 클래스 코드에 직접 추가해야 합니다.
- 이는 새로운 기능 추가를 위해 기존 핵심 코드를 계속 수정해야 함을 의미하며, **개방-폐쇄 원칙(Open-Closed Principle)**에 위배됩니다.

### 개선 방향
- 보다 일반적인(Generic) 캐시 관리 구조를 도입합니다.
- 예: `self._caches = {"raw": TTLCache(...), "jpeg": TTLCache(...)}` 와 같이 딕셔너리로 캐시들을 관리하고, `get_image(stream_id, image_type)` 와 같은 단일 메서드로 접근합니다.
- 이렇게 하면 새로운 이미지 타입이 추가되더라도 `ImageHandler`의 핵심 코드를 수정할 필요 없이 설정만으로 확장이 가능해집니다.

